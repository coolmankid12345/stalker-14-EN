using System.Numerics;
using Content.Shared._Stalker_EN.FarkleDice;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.Player;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Utility;

namespace Content.Client._Stalker_EN.FarkleDice;

[GenerateTypedNameReferences]
public sealed partial class STFarkleDiceWindow : DefaultWindow
{
    [Dependency] private readonly IEntityManager _entManager = default!;
    [Dependency] private readonly IPlayerManager _playerManager = default!;

    private readonly Button[] _diceButtons = new Button[6];
    private STFarkleDiceBoundUiState? _currentState;

    public event Action? OnJoinPressed;
    public event Action? OnLeavePressed;
    public event Action? OnRollPressed;
    public event Action<int>? OnDieSelected;
    public event Action? OnKeepAndContinuePressed;
    public event Action? OnBankPressed;
    public event Action? OnNewGamePressed;

    public STFarkleDiceWindow()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        // Create dice buttons
        for (var i = 0; i < 6; i++)
        {
            var index = i;
            var button = new Button
            {
                MinSize = new Vector2(50, 50),
                Margin = new Thickness(4, 0),
                Text = "?",
            };
            button.OnPressed += _ => OnDieSelected?.Invoke(index);
            _diceButtons[i] = button;
            DiceContainer.AddChild(button);
        }

        // Wire up button events
        JoinButton.OnPressed += _ => OnJoinPressed?.Invoke();
        LeaveButton.OnPressed += _ => OnLeavePressed?.Invoke();
        RollButton.OnPressed += _ => OnRollPressed?.Invoke();
        KeepButton.OnPressed += _ => OnKeepAndContinuePressed?.Invoke();
        BankButton.OnPressed += _ => OnBankPressed?.Invoke();
        NewGameButton.OnPressed += _ => OnNewGamePressed?.Invoke();
    }

    public void UpdateState(STFarkleDiceBoundUiState state)
    {
        _currentState = state;

        // Determine if it's the local player's turn
        var isYourTurn = IsLocalPlayersTurn(state);

        // Target score
        TargetScoreLabel.Text = Loc.GetString("farkle-target-score", ("score", state.TargetScore));

        // Player labels and scores
        Player1Label.Text = state.Player1Name ?? Loc.GetString("farkle-empty-seat");
        Player2Label.Text = state.Player2Name ?? Loc.GetString("farkle-empty-seat");
        Player1ScoreLabel.Text = state.Player1Score.ToString();
        Player2ScoreLabel.Text = state.Player2Score.ToString();

        // Highlight current player
        var player1Active = state.CurrentPlayer == 1 && state.Phase != STFarkleDicePhase.WaitingForPlayers && state.Phase != STFarkleDicePhase.GameOver;
        var player2Active = state.CurrentPlayer == 2 && state.Phase != STFarkleDicePhase.WaitingForPlayers && state.Phase != STFarkleDicePhase.GameOver;
        Player1Label.Modulate = player1Active ? Color.Yellow : Color.White;
        Player2Label.Modulate = player2Active ? Color.Yellow : Color.White;

        // Turn score
        TurnScoreLabel.Text = state.TurnScore.ToString();

        // Status message
        StatusLabel.Text = GetStatusMessage(state, isYourTurn);

        // Selection score
        SelectionScoreLabel.Text = state.SelectedScore > 0
            ? Loc.GetString("farkle-points", ("points", state.SelectedScore))
            : "-";

        // Update dice buttons
        for (var i = 0; i < 6; i++)
        {
            var button = _diceButtons[i];
            var value = state.DiceValues[i];
            var isKept = state.KeptDice[i];
            var isSelected = state.SelectedDice[i];
            var canScore = state.ScoringDice[i];

            // Display die value
            button.Text = GetDieText(value);

            // Visual states
            if (isKept)
            {
                // Kept dice are grayed out and disabled
                button.Disabled = true;
                button.Modulate = new Color(0.5f, 0.5f, 0.5f);
            }
            else if (isSelected)
            {
                // Selected dice are highlighted
                button.Disabled = false;
                button.Modulate = Color.LimeGreen;
            }
            else if (canScore && state.HasRolled)
            {
                // Scoring dice have a subtle glow
                button.Disabled = false;
                button.Modulate = new Color(1f, 1f, 0.8f);
            }
            else
            {
                // Normal state
                button.Disabled = !state.HasRolled || state.Phase != STFarkleDicePhase.SelectingDice;
                button.Modulate = Color.White;
            }

            // Disable interaction if not your turn or wrong phase
            if (!isYourTurn || state.Phase != STFarkleDicePhase.SelectingDice)
                button.Disabled = true;
        }

        // Update button visibility and states
        UpdateButtonStates(state, isYourTurn);
    }

    private bool IsLocalPlayersTurn(STFarkleDiceBoundUiState state)
    {
        var localPlayer = _playerManager.LocalEntity;
        if (localPlayer == null)
            return false;

        var localNetEntity = _entManager.GetNetEntity(localPlayer.Value);

        var currentPlayerNetEntity = state.CurrentPlayer == 1
            ? state.Player1NetEntity
            : state.Player2NetEntity;

        return currentPlayerNetEntity == localNetEntity;
    }

    private static string GetStatusMessage(STFarkleDiceBoundUiState state, bool isYourTurn)
    {
        return state.Phase switch
        {
            STFarkleDicePhase.WaitingForPlayers => Loc.GetString("farkle-waiting-for-players"),
            STFarkleDicePhase.GameOver => Loc.GetString("farkle-player-wins", ("player", GetWinner(state))),
            _ => isYourTurn
                ? Loc.GetString("farkle-your-turn")
                : Loc.GetString("farkle-opponent-turn")
        };
    }

    private static int GetWinner(STFarkleDiceBoundUiState state)
    {
        return state.Player1Score >= state.TargetScore ? 1 : 2;
    }

    private void UpdateButtonStates(STFarkleDiceBoundUiState state, bool isYourTurn)
    {
        var isWaiting = state.Phase == STFarkleDicePhase.WaitingForPlayers;
        var isGameOver = state.Phase == STFarkleDicePhase.GameOver;
        var isPlaying = !isWaiting && !isGameOver;
        var isInGame = state.Player1Name != null && state.Player2Name != null;

        // Join button: visible only when waiting for players and not already joined
        JoinButton.Visible = isWaiting || isGameOver;
        JoinButton.Disabled = state.Player1Name != null && state.Player2Name != null;

        // Leave button: visible when in game
        LeaveButton.Visible = isInGame && !isGameOver;

        // Roll button: visible during play, enabled only on your turn in rolling phase
        RollButton.Visible = isPlaying;
        RollButton.Disabled = !isYourTurn ||
                              state.Phase != STFarkleDicePhase.Rolling ||
                              state.HasRolled;

        // Keep button: visible during play, enabled with valid selection
        KeepButton.Visible = isPlaying;
        KeepButton.Disabled = !isYourTurn ||
                              state.Phase != STFarkleDicePhase.SelectingDice ||
                              state.SelectedScore == 0;

        // Bank button: visible during play, enabled when there's something to bank
        BankButton.Visible = isPlaying;
        BankButton.Disabled = !isYourTurn ||
                              state.Phase != STFarkleDicePhase.SelectingDice ||
                              (state.TurnScore == 0 && state.SelectedScore == 0);

        // New Game button: visible when game is over
        NewGameButton.Visible = isGameOver;
    }

    private static string GetDieText(int value)
    {
        return value switch
        {
            1 => "\u2680", // ⚀
            2 => "\u2681", // ⚁
            3 => "\u2682", // ⚂
            4 => "\u2683", // ⚃
            5 => "\u2684", // ⚄
            6 => "\u2685", // ⚅
            _ => "?"
        };
    }
}
